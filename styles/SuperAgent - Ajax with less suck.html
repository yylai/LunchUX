<!DOCTYPE html>
<!-- saved from url=(0041)https://visionmedia.github.io/superagent/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>SuperAgent - Ajax with less suck</title>
    <link rel="stylesheet" href="./SuperAgent - Ajax with less suck_files/style.css">
    <script src="./SuperAgent - Ajax with less suck_files/jquery.js"></script>
    <script src="./SuperAgent - Ajax with less suck_files/jquery-ui.min.js"></script>
    <script src="./SuperAgent - Ajax with less suck_files/highlight.js"></script>
    <script src="./SuperAgent - Ajax with less suck_files/jquery.tocify.min.js"></script>
    <script>
      $(function(){
        $('#menu').tocify({
          selectors: 'h2',
          hashGenerator: 'pretty'
        });
      });
    </script>
  <style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
  <body>
    <ul id="menu" class="tocify"><ul id="tocify-header0" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="test-documentation"><a>Test documentation</a></li></ul><ul id="tocify-header1" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="request-basics"><a>Request basics</a></li></ul><ul id="tocify-header2" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="setting-header-fields"><a>Setting header fields</a></li></ul><ul id="tocify-header3" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="get-requests"><a>GET requests</a></li></ul><ul id="tocify-header4" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="head-requests"><a>HEAD requests</a></li></ul><ul id="tocify-header5" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="post-/-put-requests"><a>POST / PUT requests</a></li></ul><ul id="tocify-header6" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="setting-the-content-type"><a>Setting the Content-Type</a></li></ul><ul id="tocify-header7" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="setting-accept"><a>Setting Accept</a></li></ul><ul id="tocify-header8" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="query-strings"><a>Query strings</a></li></ul><ul id="tocify-header9" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="parsing-response-bodies"><a>Parsing response bodies</a></li></ul><ul id="tocify-header10" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="response-properties"><a>Response properties</a></li></ul><ul id="tocify-header11" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="aborting-requests"><a>Aborting requests</a></li></ul><ul id="tocify-header12" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="request-timeouts"><a>Request timeouts</a></li></ul><ul id="tocify-header13" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="basic-authentication"><a>Basic authentication</a></li></ul><ul id="tocify-header14" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="following-redirects"><a>Following redirects</a></li></ul><ul id="tocify-header15" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="piping-data"><a>Piping data</a></li></ul><ul id="tocify-header16" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="multipart-requests"><a>Multipart requests</a></li></ul><ul id="tocify-header17" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="compression"><a>Compression</a></li></ul><ul id="tocify-header18" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="buffering-responses"><a>Buffering responses</a></li></ul><ul id="tocify-header19" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="cors"><a>CORS</a></li></ul><ul id="tocify-header20" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="error-handling"><a>Error handling</a></li></ul><ul id="tocify-header21" class="tocify-header nav nav-list"><li class="tocify-item" data-unique="generator-support"><a>Generator support</a></li></ul></ul>
    <div id="content">
<h1 id="superagent">SuperAgent</h1>
<p> Super Agent is light-weight progressive ajax API crafted for flexibility, readability, and a low learning curve after being frustrated with many of the existing request APIs. It also works with Node.js!</p>
<pre><code> request
   .post(<span class="string">'/api/pet'</span>)
   .send({ name: <span class="string">'Manny'</span>, species: <span class="string">'cat'</span> })
   .set(<span class="string">'X-API-Key'</span>, <span class="string">'foobar'</span>)
   .set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)
   .end(<span class="keyword">function</span>(err, res){
     <span class="keyword">if</span> (err || !res.ok) {
       alert(<span class="string">'Oh no! error'</span>);
     } <span class="keyword">else</span> {
       alert(<span class="string">'yay got '</span> + JSON.stringify(res.body));
     }
   });
</code></pre><div name="test-documentation" data-unique="test-documentation"></div><h2 id="test-documentation">Test documentation</h2>
<p>  The following <a href="https://visionmedia.github.io/superagent/docs/test.html">test documentation</a> was generated with <a href="http://visionmedia.github.com/mocha">Mocha's</a> "doc" reporter, and directly reflects the test suite. This provides an additional source of documentation.</p>
<div name="request-basics" data-unique="request-basics"></div><h2 id="request-basics">Request basics</h2>
<p> A request can be initiated by invoking the appropriate method on the <code>request</code> object, then calling <code>.end()</code> to send the request. For example a simple GET request:</p>
<pre><code> request
   .get(<span class="string">'/search'</span>)
   .end(<span class="keyword">function</span>(err, res){

   });
</code></pre><p>  A method string may also be passed:</p>
<pre><code>request(<span class="string">'GET'</span>, <span class="string">'/search'</span>).end(callback);
</code></pre><p> The <strong>node</strong> client may also provide absolute urls:</p>
<pre><code> request
   .get(<span class="string">'http://example.com/search'</span>)
   .end(<span class="keyword">function</span>(err, res){

   });
</code></pre><p>  <strong>DELETE</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong> and other <strong>HTTP</strong> verbs may also be used, simply change the method name:</p>
<pre><code>request
  .head(<span class="string">'/favicon.ico'</span>)
  .end(<span class="keyword">function</span>(err, res){

  });
</code></pre><p>  <strong>DELETE</strong> is a special-case, as it's a reserved word, so the method is named <code>.del()</code>:</p>
<pre><code>request
  .del(<span class="string">'/user/<span class="number">1</span>'</span>)
  .end(<span class="keyword">function</span>(err, res){

  });
</code></pre><p>  The HTTP method defaults to <strong>GET</strong>, so if you wish, the following is valid:</p>
<pre><code> request(<span class="string">'/search'</span>, <span class="keyword">function</span>(err, res){

 });
</code></pre><div name="setting-header-fields" data-unique="setting-header-fields"></div><h2 id="setting-header-fields">Setting header fields</h2>
<p>  Setting header fields is simple, invoke <code>.set()</code> with a field name and value:</p>
<pre><code> request
   .get(<span class="string">'/search'</span>)
   .set(<span class="string">'API-Key'</span>, <span class="string">'foobar'</span>)
   .set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)
   .end(callback);
</code></pre><p>  You may also pass an object to set several fields in a single call:</p>
<pre><code> request
   .get(<span class="string">'/search'</span>)
   .set({ <span class="string">'API-Key'</span>: <span class="string">'foobar'</span>, Accept: <span class="string">'application/json'</span> })
   .end(callback);
</code></pre><div name="get-requests" data-unique="get-requests"></div><h2 id="get-requests">GET requests</h2>
<p> The <code>.query()</code> method accepts objects, which when used with the <strong>GET</strong> method will form a query-string. The following will produce the path <code>/search?query=Manny&amp;range=<span class="number">1</span>..<span class="number">5</span>&amp;order=desc</code>.</p>
<pre><code> request
   .get(<span class="string">'/search'</span>)
   .query({ query: <span class="string">'Manny'</span> })
   .query({ range: <span class="string">'<span class="number">1</span>..<span class="number">5</span>'</span> })
   .query({ order: <span class="string">'desc'</span> })
   .end(<span class="keyword">function</span>(err, res){

   });
</code></pre><p>  Or as a single object:</p>
<pre><code>request
  .get(<span class="string">'/search'</span>)
  .query({ query: <span class="string">'Manny'</span>, range: <span class="string">'<span class="number">1</span>..<span class="number">5</span>'</span>, order: <span class="string">'desc'</span> })
  .end(<span class="keyword">function</span>(err, res){

  });
</code></pre><p>  The <code>.query()</code> method accepts strings as well:</p>
<pre><code>  request
    .get(<span class="string">'/querystring'</span>)
    .query(<span class="string">'search=Manny&amp;range=<span class="number">1</span>..<span class="number">5</span>'</span>)
    .end(<span class="keyword">function</span>(err, res){

    });
</code></pre><p>  Or joined:</p>
<pre><code>  request
    .get(<span class="string">'/querystring'</span>)
    .query(<span class="string">'search=Manny'</span>)
    .query(<span class="string">'range=<span class="number">1</span>..<span class="number">5</span>'</span>)
    .end(<span class="keyword">function</span>(err, res){

    });
</code></pre><div name="head-requests" data-unique="head-requests"></div><h2 id="head-requests">HEAD requests</h2>
<p>You can also use the <code>.query()</code> method for HEAD requests. The following will produce the path <code>/users?email=joe@smith.com</code>.</p>
<pre><code>  request
    .head(<span class="string">'/users'</span>)
    .query({ email: <span class="string">'joe@smith.com'</span> })
    .end(<span class="keyword">function</span>(err, res){

    });
</code></pre><div name="post-/-put-requests" data-unique="post-/-put-requests"></div><h2 id="post-put-requests">POST / PUT requests</h2>
<p>  A typical JSON <strong>POST</strong> request might look a little like the following, where we set the Content-Type header field appropriately, and "write" some data, in this case just a JSON string.</p>
<pre><code>  request.post(<span class="string">'/user'</span>)
    .set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)
    .send(<span class="string">'{"name":"tj","pet":"tobi"}'</span>)
    .end(callback)
</code></pre><p>  Since JSON is undoubtably the most common, it's the <em>default</em>! The following example is equivalent to the previous.</p>
<pre><code>  request.post(<span class="string">'/user'</span>)
    .send({ name: <span class="string">'tj'</span>, pet: <span class="string">'tobi'</span> })
    .end(callback)
</code></pre><p>  Or using multiple <code>.send()</code> calls:</p>
<pre><code>  request.post(<span class="string">'/user'</span>)
    .send({ name: <span class="string">'tj'</span> })
    .send({ pet: <span class="string">'tobi'</span> })
    .end(callback)
</code></pre><p>  By default sending strings will set the Content-Type to <code>application/x-www-form-urlencoded</code>,
  multiple calls will be concatenated with <code>&amp;</code>, here resulting in <code>name=tj&amp;pet=tobi</code>:</p>
<pre><code>  request.post(<span class="string">'/user'</span>)
    .send(<span class="string">'name=tj'</span>)
    .send(<span class="string">'pet=tobi'</span>)
    .end(callback);
</code></pre><p>  SuperAgent formats are extensible, however by default "json" and "form" are supported. To send the data as <code>application/x-www-form-urlencoded</code> simply invoke <code>.type()</code> with "form", where the default is "json". This request will POST the body "name=tj&amp;pet=tobi".</p>
<pre><code>  request.post(<span class="string">'/user'</span>)
    .type(<span class="string">'form'</span>)
    .send({ name: <span class="string">'tj'</span> })
    .send({ pet: <span class="string">'tobi'</span> })
    .end(callback)
</code></pre><p> Note: "form" is aliased as "form-data" and "urlencoded" for backwards compat.</p>
<div name="setting-the-content-type" data-unique="setting-the-content-type"></div><h2 id="setting-the-content-type">Setting the Content-Type</h2>
<p>  The obvious solution is to use the <code>.set()</code> method:</p>
<pre><code> request.post(<span class="string">'/user'</span>)
   .set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)
</code></pre><p>  As a short-hand the <code>.type()</code> method is also available, accepting
  the canonicalized MIME type name complete with type/subtype, or
  simply the extension name such as "xml", "json", "png", etc:</p>
<pre><code> request.post(<span class="string">'/user'</span>)
   .type(<span class="string">'application/json'</span>)

 request.post(<span class="string">'/user'</span>)
   .type(<span class="string">'json'</span>)

 request.post(<span class="string">'/user'</span>)
   .type(<span class="string">'png'</span>)
</code></pre><div name="setting-accept" data-unique="setting-accept"></div><h2 id="setting-accept">Setting Accept</h2>
<p>In a similar fashion to the <code>.type()</code> method it is also possible to set the Accept header via the short hand method <code>.accept()</code>. Which references <code>request.types</code> as well allowing you to specify either the full canonicalized MIME type name as type/subtype, or the extension suffix form as "xml", "json", "png", etc for convenience:</p>
<pre><code> request.get(<span class="string">'/user'</span>)
   .accept(<span class="string">'application/json'</span>)

 request.get(<span class="string">'/user'</span>)
   .accept(<span class="string">'json'</span>)

 request.post(<span class="string">'/user'</span>)
   .accept(<span class="string">'png'</span>)
</code></pre><div name="query-strings" data-unique="query-strings"></div><h2 id="query-strings">Query strings</h2>
<p>  <code>res.query(obj)</code> is a method which may be used to build up a query-string. For example populating <code>?format=json&amp;dest=/login</code> on a <strong>POST</strong>:</p>
<pre><code>request
  .post(<span class="string">'/'</span>)
  .query({ format: <span class="string">'json'</span> })
  .query({ dest: <span class="string">'/login'</span> })
  .send({ post: <span class="string">'data'</span>, here: <span class="string">'wahoo'</span> })
  .end(callback);
</code></pre><div name="parsing-response-bodies" data-unique="parsing-response-bodies"></div><h2 id="parsing-response-bodies">Parsing response bodies</h2>
<p>  Super Agent will parse known response-body data for you, currently supporting <em>application/x-www-form-urlencoded</em>, <em>application/json</em>, and <em>multipart/form-data</em>.</p>
<h3 id="json-urlencoded">JSON / Urlencoded</h3>
<p>  The property <code>res.body</code> is the parsed object, for example if a request responded with the JSON string '{"user":{"name":"tobi"}}', <code>res.body.user.name</code> would be "tobi". Likewise the x-www-form-urlencoded value of "user[name]=tobi" would yield the same result.</p>
<h3 id="multipart">Multipart</h3>
<p>  The Node client supports <em>multipart/form-data</em> via the <a href="https://github.com/felixge/node-formidable">Formidable</a> module. When parsing multipart responses, the object <code>res.files</code> is also available to you. Suppose for example a request responds with the following multipart body:</p>
<pre><code>--whoop
Content-Disposition: attachment; name="image"; filename="tobi.png"
Content-Type: image/png

... data here ...
--whoop
Content-Disposition: form-data; name="name"
Content-Type: text/plain

Tobi
--whoop--
</code></pre><p>  You would have the values <code>res.body.name</code> provided as "Tobi", and <code>res.files.image</code> as a <code>File</code> object containing the path on disk, filename, and other properties.</p>
<div name="response-properties" data-unique="response-properties"></div><h2 id="response-properties">Response properties</h2>
<p>  Many helpful flags and properties are set on the <code>Response</code> object, ranging from the response text, parsed response body, header fields, status flags and more.</p>
<h3 id="response-text">Response text</h3>
<p>  The <code>res.text</code> property contains the unparsed response body string. This
  property is always present for the client API, and only when the mime type
  matches "text/<em>", "</em>/json", or "x-www-form-urlencoding" by default for node. The
  reasoning is to conserve memory, as buffering text of large bodies such as multipart files or images is extremely inefficient.</p>
<p>  To force buffering see the "Buffering responses" section.</p>
<h3 id="response-body">Response body</h3>
<p>  Much like SuperAgent can auto-serialize request data, it can also automatically parse it. When a parser is defined for the Content-Type, it is parsed, which by default includes "application/json" and "application/x-www-form-urlencoded". The parsed object is then available via <code>res.body</code>.</p>
<h3 id="response-header-fields">Response header fields</h3>
<p>  The <code>res.header</code> contains an object of parsed header fields, lowercasing field names much like node does. For example <code>res.header[<span class="string">'content-length'</span>]</code>.</p>
<h3 id="response-content-type">Response Content-Type</h3>
<p>  The Content-Type response header is special-cased, providing <code>res.type</code>, which is void of the charset (if any). For example the Content-Type of "text/html; charset=utf8" will provide "text/html" as <code>res.type</code>, and the <code>res.charset</code> property would then contain "utf8".</p>
<h3 id="response-status">Response status</h3>
<p>  The response status flags help determine if the request was a success, among other useful information, making SuperAgent ideal for interacting with RESTful web services. These flags are currently defined as:</p>
<pre><code> <span class="keyword">var</span> type = status / <span class="number">100</span> | <span class="number">0</span>;

 // status / class
 res.status = status;
 res.statusType = type;

 // basics
 res.info = <span class="number">1</span> == type;
 res.ok = <span class="number">2</span> == type;
 res.clientError = <span class="number">4</span> == type;
 res.serverError = <span class="number">5</span> == type;
 res.error = <span class="number">4</span> == type || <span class="number">5</span> == type;

 // sugar
 res.accepted = <span class="number">202</span> == status;
 res.noContent = <span class="number">204</span> == status || <span class="number">1223</span> == status;
 res.badRequest = <span class="number">400</span> == status;
 res.unauthorized = <span class="number">401</span> == status;
 res.notAcceptable = <span class="number">406</span> == status;
 res.notFound = <span class="number">404</span> == status;
 res.forbidden = <span class="number">403</span> == status;
</code></pre><div name="aborting-requests" data-unique="aborting-requests"></div><h2 id="aborting-requests">Aborting requests</h2>
<p>  To abort requests simply invoke the <code>req.abort()</code> method.</p>
<div name="request-timeouts" data-unique="request-timeouts"></div><h2 id="request-timeouts">Request timeouts</h2>
<p>  A timeout can be applied by invoking <code>req.timeout(ms)</code>, after which an error
  will be triggered. To differentiate between other errors the <code>err.timeout</code> property
  is set to the <code>ms</code> value. <strong>NOTE</strong> that this is a timeout applied to the request
  and all subsequent redirects, not per request.</p>
<div name="basic-authentication" data-unique="basic-authentication"></div><h2 id="basic-authentication">Basic authentication</h2>
<p>  Basic auth is currently provided by the <em>node</em> client in two forms, first via the URL as "user:pass":</p>
<pre><code>request.get(<span class="string">'http://tobi:learnboost@local'</span>).end(callback);
</code></pre><p>  As well as via the <code>.auth()</code> method:</p>
<pre><code>request
  .get(<span class="string">'http://local'</span>)
  .auth(<span class="string">'tobi'</span>, <span class="string">'learnboost'</span>)
  .end(callback);
</code></pre><div name="following-redirects" data-unique="following-redirects"></div><h2 id="following-redirects">Following redirects</h2>
<p>  By default up to 5 redirects will be followed, however you may specify this with the <code>res.redirects(n)</code> method:</p>
<pre><code>request
  .get(<span class="string">'/some.png'</span>)
  .redirects(<span class="number">2</span>)
  .end(callback);
</code></pre><div name="piping-data" data-unique="piping-data"></div><h2 id="piping-data">Piping data</h2>
<p>  The Node client allows you to pipe data to and from the request. For example piping a file's contents as the request:</p>
<pre><code><span class="keyword">var</span> request = require(<span class="string">'superagent'</span>)
  , fs = require(<span class="string">'fs'</span>);

<span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'path/to/my.json'</span>);
<span class="keyword">var</span> req = request.post(<span class="string">'/somewhere'</span>);
req.type(<span class="string">'json'</span>);
stream.pipe(req);
</code></pre><p>  Or piping the response to a file:</p>
<pre><code><span class="keyword">var</span> request = require(<span class="string">'superagent'</span>)
  , fs = require(<span class="string">'fs'</span>);

<span class="keyword">var</span> stream = fs.createWriteStream(<span class="string">'path/to/my.json'</span>);
<span class="keyword">var</span> req = request.get(<span class="string">'/some.json'</span>);
req.pipe(stream);
</code></pre><div name="multipart-requests" data-unique="multipart-requests"></div><h2 id="multipart-requests">Multipart requests</h2>
<p>  Super Agent is also great for <em>building</em> multipart requests for which it provides methods <code>.attach()</code> and <code>.field()</code>.</p>
<h3 id="attaching-files">Attaching files</h3>
<p>  As mentioned a higher-level API is also provided, in the form of <code>.attach(name, [path], [filename])</code> and <code>.field(name, value)</code>. Attaching several files is simple, you can also provide a custom filename for the attachment, otherwise the basename of the attached file is used.</p>
<pre><code>request
  .post(<span class="string">'/upload'</span>)
  .attach(<span class="string">'avatar'</span>, <span class="string">'path/to/tobi.png'</span>, <span class="string">'user.png'</span>)
  .attach(<span class="string">'image'</span>, <span class="string">'path/to/loki.png'</span>)
  .attach(<span class="string">'file'</span>, <span class="string">'path/to/jane.png'</span>)
  .end(callback);
</code></pre><h3 id="field-values">Field values</h3>
<p>  Much like form fields in HTML, you can set field values with the <code>.field(name, value)</code> method. Suppose you want to upload a few images with your name and email, your request might look something like this:</p>
<pre><code> request
   .post(<span class="string">'/upload'</span>)
   .field(<span class="string">'user[name]'</span>, <span class="string">'Tobi'</span>)
   .field(<span class="string">'user[email]'</span>, <span class="string">'tobi@learnboost.com'</span>)
   .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)
   .end(callback);
</code></pre><div name="compression" data-unique="compression"></div><h2 id="compression">Compression</h2>
<p>  The node client supports compressed responses, best of all, you don't have to do anything! It just works.</p>
<div name="buffering-responses" data-unique="buffering-responses"></div><h2 id="buffering-responses">Buffering responses</h2>
<p>  To force buffering of response bodies as <code>res.text</code> you may invoke <code>req.buffer()</code>. To undo the default of buffering for text responses such
  as "text/plain", "text/html" etc you may invoke <code>req.buffer(false)</code>.</p>
<p>  When buffered the <code>res.buffered</code> flag is provided, you may use this to
  handle both buffered and unbuffered responses in the same callback.</p>
<div name="cors" data-unique="cors"></div><h2 id="cors">CORS</h2>
<p>  The <code>.withCredentials()</code> method enables the ability to send cookies
  from the origin, however only when "Access-Control-Allow-Origin" is
  <em>not</em> a wildcard ("*"), and "Access-Control-Allow-Credentials" is "true".</p>
<pre><code>request
  .get(<span class="string">'http://localhost:<span class="number">4001</span>/'</span>)
  .withCredentials()
  .end(<span class="keyword">function</span>(err, res){
    assert(<span class="number">200</span> == res.status);
    assert(<span class="string">'tobi'</span> == res.text);
    next();
  })
</code></pre><div name="error-handling" data-unique="error-handling"></div><h2 id="error-handling">Error handling</h2>
<p>Your callback function will always be passed two arguments: error and response. If no error occurred, the first argument will be null:</p>
<pre><code>request
 .post(<span class="string">'/upload'</span>)
 .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)
 .end(<span class="keyword">function</span>(err, res){

 });

 An "error" event is also emitted, with you can listen for:

request
  .post(<span class="string">'/upload'</span>)
  .attach(<span class="string">'image'</span>, <span class="string">'path/to/tobi.png'</span>)
  .on(<span class="string">'error'</span>, handle)
  .end(<span class="keyword">function</span>(err, res){

  });
</code></pre><p>  Note that a 4xx or 5xx response with super agent <strong>are</strong> considered an error by default. For example if you get a 500 or 403 response, this status information will be available via <code>err.status</code>. Errors from such responses also contain an <code>err.response</code> field with all of the properties mentioned in "Response properties". The library behaves in this way to handle the common case of wanting success responses and treating HTTP error status codes as errors while still allowing for custom logic around specific error conditions.</p>
<p>  Network failures, timeouts, and other errors that produce no response will contain no <code>err.status</code> or <code>err.response</code> fields.</p>
<p>  If you wish to handle 404 or other HTTP error responses, you can query the <code>err.status</code> property.
  When an HTTP error occurs (4xx or 5xx response) the <code>res.error</code> property is an <code>Error</code> object,
  this allows you to perform checks such as:</p>
<pre><code><span class="keyword">if</span> (err &amp;&amp; err.status === <span class="number">404</span>) {
  alert(<span class="string">'oh no '</span> + res.body.message);
}
<span class="keyword">else</span> <span class="keyword">if</span> (err) {
  // all other error types we handle generically
}
</code></pre><div name="generator-support" data-unique="generator-support"></div><h2 id="generator-support">Generator support</h2>
<p>Superagent now supports easier control flow using generators. By using a generator control flow
like <a href="https://github.com/tj/co">co</a> or a web framework like <a href="https://github.com/koajs/koa">koa</a>,
you can <code>yield</code> on any superagent method:</p>
<pre><code><span class="keyword">var</span> res = yield request
  .get(<span class="string">'http://local'</span>)
  .auth(<span class="string">'tobi'</span>, <span class="string">'learnboost'</span>)
</code></pre>
    </div>
    <a href="http://github.com/visionmedia/superagent"><img style="position: absolute; top: 0; right: 0; border: 0;" src="./SuperAgent - Ajax with less suck_files/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>
  
</body></html>